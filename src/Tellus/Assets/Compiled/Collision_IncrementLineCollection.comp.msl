#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

struct LineData
{
    float2 Origin;
    float2 Vector;
    float Length;
    int Flags;
};

struct type_StructuredBuffer_LineData
{
    LineData _m0[1];
};

struct LineCollectionData
{
    int LineIndexStart;
    int LineIndexLength;
    float2 Offset;
    int LineVelocityIndex;
    int Padding;
};

struct type_RWStructuredBuffer_LineCollectionData
{
    LineCollectionData _m0[1];
};

struct type_UniformBlock
{
    int LineCollectionDataBufferStartIndex;
    int LineCollectionDataBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_LineData& LineDataBuffer [[buffer(1)]], device type_RWStructuredBuffer_LineCollectionData& LineCollectionCasterDataBuffer [[buffer(2)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        if (gl_GlobalInvocationID.x >= uint(UniformBlock.LineCollectionDataBufferLength))
        {
            break;
        }
        uint _49 = gl_GlobalInvocationID.x + uint(UniformBlock.LineCollectionDataBufferStartIndex);
        int _51 = LineCollectionCasterDataBuffer._m0[_49].LineVelocityIndex;
        uint _52 = uint(_51);
        LineData _54 = LineDataBuffer._m0[_52];
        if ((_54.Flags & 2) == 2)
        {
            LineCollectionCasterDataBuffer._m0[_49].Offset += (fast::normalize(_54.Vector - _54.Origin) * _54.Length);
        }
        else
        {
            LineCollectionCasterDataBuffer._m0[_49].Offset += (_54.Vector * _54.Length);
        }
        break;
    } while(false);
}

