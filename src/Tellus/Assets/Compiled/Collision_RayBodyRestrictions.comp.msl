#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct CollisionBodyPartData
{
    int CollisionBodyIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_CollisionBodyPartData
{
    CollisionBodyPartData _m0[1];
};

struct CollisionBodyData
{
    int BodyPartIndexStart;
    int BodyPartIndexLength;
    float2 Offset;
};

struct type_StructuredBuffer_CollisionBodyData
{
    CollisionBodyData _m0[1];
};

struct RayCasterData
{
    int RayIndexStart;
    int RayIndexLength;
    float2 Offset;
    int RayVelocityIndex;
    int Padding;
};

struct type_StructuredBuffer_RayCasterData
{
    RayCasterData _m0[1];
};

struct RayData
{
    float2 Origin;
    float2 Direction;
    float Length;
    int Flags;
};

struct type_RWStructuredBuffer_RayData
{
    RayData _m0[1];
};

struct type_UniformBlock
{
    int BodyDataBufferStartIndex;
    int BodyDataBufferLength;
    int RayCasterDataBufferStartIndex;
    int RayCasterDataBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_CollisionBodyPartData& BodyPartDataBuffer [[buffer(1)]], const device type_StructuredBuffer_CollisionBodyData& BodyDataBuffer [[buffer(2)]], const device type_StructuredBuffer_RayCasterData& RayCasterDataBuffer [[buffer(3)]], device type_RWStructuredBuffer_RayData& RayDataBuffer [[buffer(4)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        if (gl_GlobalInvocationID.x >= uint(UniformBlock.RayCasterDataBufferLength))
        {
            break;
        }
        uint _86 = gl_GlobalInvocationID.x + uint(UniformBlock.RayCasterDataBufferStartIndex);
        spvUnsafeArray<float2, 16> _72;
        for (int _94 = 0; _94 < RayCasterDataBuffer._m0[_86].RayIndexLength; _94++)
        {
            uint _101 = uint(_94 + RayCasterDataBuffer._m0[_86].RayIndexStart);
            float2 _108 = RayDataBuffer._m0[_101].Origin + RayCasterDataBuffer._m0[_86].Offset;
            if ((RayDataBuffer._m0[_101].Flags & 1) == 0)
            {
                continue;
            }
            float _114;
            _114 = RayDataBuffer._m0[_101].Length;
            float _115;
            for (int _117 = 0; _117 < UniformBlock.BodyDataBufferLength; _114 = _115, _117++)
            {
                uint _127 = uint(_117 + UniformBlock.BodyDataBufferStartIndex);
                _115 = _114;
                float _137;
                for (int _134 = 0; _134 < BodyDataBuffer._m0[_127].BodyPartIndexLength; _134++, _115 = _137)
                {
                    uint _142 = uint(_134 + BodyDataBuffer._m0[_127].BodyPartIndexStart);
                    for (int _152 = 0; _152 < 16; )
                    {
                        _72[_152] = float2(0.0);
                        _152++;
                        continue;
                    }
                    int _237;
                    if (BodyPartDataBuffer._m0[_142].ShapeType == 0)
                    {
                        for (int _222 = 0; _222 < BodyPartDataBuffer._m0[_142].IntegerFields.x; )
                        {
                            float _230 = (6.283185482025146484375 * float(_222)) / float(BodyPartDataBuffer._m0[_142].IntegerFields.x);
                            _72[_222] = BodyPartDataBuffer._m0[_142].Center + (float2(cos(_230), sin(_230)) * BodyPartDataBuffer._m0[_142].DecimalFields.x);
                            _222++;
                            continue;
                        }
                        _237 = BodyPartDataBuffer._m0[_142].IntegerFields.x;
                    }
                    else
                    {
                        int _218;
                        if (BodyPartDataBuffer._m0[_142].ShapeType == 1)
                        {
                            float _180 = sin(BodyPartDataBuffer._m0[_142].DecimalFields.x);
                            float _181 = cos(BodyPartDataBuffer._m0[_142].DecimalFields.x);
                            float _184 = BodyPartDataBuffer._m0[_142].DecimalFields.y * (-0.5);
                            float _185 = BodyPartDataBuffer._m0[_142].DecimalFields.z * (-0.5);
                            _72[0] = float2(_184, _185);
                            float _188 = BodyPartDataBuffer._m0[_142].DecimalFields.y * 0.5;
                            _72[1] = float2(_188, _185);
                            float _191 = BodyPartDataBuffer._m0[_142].DecimalFields.z * 0.5;
                            _72[2] = float2(_188, _191);
                            _72[3] = float2(_184, _191);
                            for (int _197 = 0; _197 < 4; )
                            {
                                float _211 = _72[_197].x;
                                float _213 = _72[_197].y;
                                _72[_197].x = (_72[_197].x * _181) + (_72[_197].y * (-_180));
                                _72[_197].y = (_211 * _180) + (_213 * _181);
                                _72[_197] += BodyPartDataBuffer._m0[_142].Center;
                                _197++;
                                continue;
                            }
                            _218 = 4;
                        }
                        else
                        {
                            bool _166 = BodyPartDataBuffer._m0[_142].ShapeType == 2;
                            if (_166)
                            {
                                _72[0] = BodyPartDataBuffer._m0[_142].Center;
                                _72[1] = float2(BodyPartDataBuffer._m0[_142].DecimalFields.xy);
                                _72[2] = float2(BodyPartDataBuffer._m0[_142].DecimalFields.zw);
                            }
                            _218 = _166 ? 3 : 1;
                        }
                        _237 = _218;
                    }
                    for (int _239 = 0; _239 < 16; )
                    {
                        _72[_239] += BodyDataBuffer._m0[_127].Offset;
                        _239++;
                        continue;
                    }
                    _137 = _115;
                    float _248;
                    for (int _250 = 0; _250 < _237; _137 = _248, _250++)
                    {
                        int _261;
                        if (_250 == (_237 - 1))
                        {
                            _261 = 0;
                        }
                        else
                        {
                            _261 = _250 + 1;
                        }
                        float2 _331;
                        bool _332;
                        do
                        {
                            float2 _275 = fast::normalize(_72[_261] - _72[_250]) * length(_72[_261] - _72[_250]);
                            float2 _276 = RayDataBuffer._m0[_101].Direction * RayDataBuffer._m0[_101].Length;
                            float2 _277 = _108 - _72[_250];
                            float _278 = _277.x;
                            float _279 = _276.y;
                            float _281 = _277.y;
                            float _282 = _276.x;
                            float _285 = _275.y;
                            float _287 = _275.x;
                            float _289 = (_278 * _285) - (_281 * _287);
                            float _292 = (_287 * _279) - (_285 * _282);
                            bool _294 = abs(_292) < 0.001000000047497451305389404296875;
                            bool _296 = abs(_289) < 0.001000000047497451305389404296875;
                            bool _301;
                            if (_294)
                            {
                                _301 = !_296;
                            }
                            else
                            {
                                _301 = false;
                            }
                            if (_294 ? _296 : false)
                            {
                                _331 = float2(0.0);
                                _332 = false;
                                break;
                            }
                            else
                            {
                                if (_301)
                                {
                                    _331 = float2(0.0);
                                    _332 = false;
                                    break;
                                }
                                else
                                {
                                    if (!_294)
                                    {
                                        float _312 = ((_278 * _279) - (_281 * _282)) / _292;
                                        float _313 = _289 / _292;
                                        bool _318;
                                        if (_312 >= 0.0)
                                        {
                                            _318 = _312 <= 1.0;
                                        }
                                        else
                                        {
                                            _318 = false;
                                        }
                                        bool _326;
                                        if (_318)
                                        {
                                            bool _325;
                                            if (_313 >= 0.0)
                                            {
                                                _325 = _313 <= 1.0;
                                            }
                                            else
                                            {
                                                _325 = false;
                                            }
                                            _326 = _325;
                                        }
                                        else
                                        {
                                            _326 = false;
                                        }
                                        if (_326)
                                        {
                                            _331 = _108 + (_276 * _313);
                                            _332 = true;
                                            break;
                                        }
                                        _331 = float2(0.0);
                                        _332 = false;
                                        break;
                                    }
                                    else
                                    {
                                        _331 = float2(0.0);
                                        _332 = false;
                                        break;
                                    }
                                    break; // unreachable workaround
                                }
                                break; // unreachable workaround
                            }
                            break; // unreachable workaround
                        } while(false);
                        if (_332)
                        {
                            float _336 = length(_331 - _108);
                            _248 = (_336 < _137) ? _336 : _137;
                        }
                        else
                        {
                            _248 = _137;
                        }
                    }
                }
            }
            RayDataBuffer._m0[_101].Length = _114;
        }
        break;
    } while(false);
}

