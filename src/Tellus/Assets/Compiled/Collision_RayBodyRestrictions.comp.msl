#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct CollisionBodyPartData
{
    int CollisionBodyIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_CollisionBodyPartData
{
    CollisionBodyPartData _m0[1];
};

struct CollisionBodyData
{
    int BodyPartIndexStart;
    int BodyPartIndexLength;
    float2 Offset;
};

struct type_StructuredBuffer_CollisionBodyData
{
    CollisionBodyData _m0[1];
};

struct RayCasterData
{
    int RayIndexStart;
    int RayIndexLength;
    float2 Offset;
    int RayVelocityIndex;
    char _m0_final_padding[4];
};

struct type_StructuredBuffer_RayCasterData
{
    RayCasterData _m0[1];
};

struct RayData
{
    float2 Origin;
    float2 Direction;
    float Length;
    char _m0_final_padding[4];
};

struct type_RWStructuredBuffer_RayData
{
    RayData _m0[1];
};

struct type_UniformBlock
{
    uint StoredBodyCount;
    uint StoredRayCasterCount;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_CollisionBodyPartData& BodyPartDataBuffer [[buffer(1)]], const device type_StructuredBuffer_CollisionBodyData& BodyDataBuffer [[buffer(2)]], const device type_StructuredBuffer_RayCasterData& RayCasterDataBuffer [[buffer(3)]], device type_RWStructuredBuffer_RayData& RayDataBuffer [[buffer(4)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        if (gl_GlobalInvocationID.x >= UniformBlock.StoredRayCasterCount)
        {
            break;
        }
        spvUnsafeArray<float2, 16> _73;
        for (int _90 = 0; _90 < RayCasterDataBuffer._m0[gl_GlobalInvocationID.x].RayIndexLength; _90++)
        {
            uint _97 = uint(_90 + RayCasterDataBuffer._m0[gl_GlobalInvocationID.x].RayIndexStart);
            float2 _103 = RayDataBuffer._m0[_97].Origin + RayCasterDataBuffer._m0[gl_GlobalInvocationID.x].Offset;
            float _105;
            int _108;
            _105 = RayDataBuffer._m0[_97].Length;
            _108 = 0;
            float _106;
            uint _110;
            for (;;)
            {
                _110 = uint(_108);
                if (_110 < UniformBlock.StoredBodyCount)
                {
                    _106 = _105;
                    float _125;
                    for (int _122 = 0; _122 < BodyDataBuffer._m0[_110].BodyPartIndexLength; _122++, _106 = _125)
                    {
                        uint _130 = uint(_122 + BodyDataBuffer._m0[_110].BodyPartIndexStart);
                        for (int _140 = 0; _140 < 16; )
                        {
                            _73[_140] = float2(0.0);
                            _140++;
                            continue;
                        }
                        int _225;
                        if (BodyPartDataBuffer._m0[_130].ShapeType == 0)
                        {
                            for (int _210 = 0; _210 < BodyPartDataBuffer._m0[_130].IntegerFields.x; )
                            {
                                float _218 = (6.283185482025146484375 * float(_210)) / float(BodyPartDataBuffer._m0[_130].IntegerFields.x);
                                _73[_210] = BodyPartDataBuffer._m0[_130].Center + (float2(cos(_218), sin(_218)) * BodyPartDataBuffer._m0[_130].DecimalFields.x);
                                _210++;
                                continue;
                            }
                            _225 = BodyPartDataBuffer._m0[_130].IntegerFields.x;
                        }
                        else
                        {
                            int _206;
                            if (BodyPartDataBuffer._m0[_130].ShapeType == 1)
                            {
                                float _168 = sin(BodyPartDataBuffer._m0[_130].DecimalFields.x);
                                float _169 = cos(BodyPartDataBuffer._m0[_130].DecimalFields.x);
                                float _172 = BodyPartDataBuffer._m0[_130].DecimalFields.y * (-0.5);
                                float _173 = BodyPartDataBuffer._m0[_130].DecimalFields.z * (-0.5);
                                _73[0] = float2(_172, _173);
                                float _176 = BodyPartDataBuffer._m0[_130].DecimalFields.y * 0.5;
                                _73[1] = float2(_176, _173);
                                float _179 = BodyPartDataBuffer._m0[_130].DecimalFields.z * 0.5;
                                _73[2] = float2(_176, _179);
                                _73[3] = float2(_172, _179);
                                for (int _185 = 0; _185 < 4; )
                                {
                                    float _199 = _73[_185].x;
                                    float _201 = _73[_185].y;
                                    _73[_185].x = (_73[_185].x * _169) + (_73[_185].y * (-_168));
                                    _73[_185].y = (_199 * _168) + (_201 * _169);
                                    _73[_185] += BodyPartDataBuffer._m0[_130].Center;
                                    _185++;
                                    continue;
                                }
                                _206 = 4;
                            }
                            else
                            {
                                bool _154 = BodyPartDataBuffer._m0[_130].ShapeType == 2;
                                if (_154)
                                {
                                    _73[0] = BodyPartDataBuffer._m0[_130].Center;
                                    _73[1] = float2(BodyPartDataBuffer._m0[_130].DecimalFields.xy);
                                    _73[2] = float2(BodyPartDataBuffer._m0[_130].DecimalFields.zw);
                                }
                                _206 = _154 ? 3 : 1;
                            }
                            _225 = _206;
                        }
                        for (int _227 = 0; _227 < 16; )
                        {
                            _73[_227] += BodyDataBuffer._m0[_110].Offset;
                            _227++;
                            continue;
                        }
                        _125 = _106;
                        float _236;
                        for (int _238 = 0; _238 < _225; _125 = _236, _238++)
                        {
                            int _249;
                            if (_238 == (_225 - 1))
                            {
                                _249 = 0;
                            }
                            else
                            {
                                _249 = _238 + 1;
                            }
                            float2 _319;
                            bool _320;
                            do
                            {
                                float2 _263 = fast::normalize(_73[_249] - _73[_238]) * length(_73[_249] - _73[_238]);
                                float2 _264 = RayDataBuffer._m0[_97].Direction * RayDataBuffer._m0[_97].Length;
                                float2 _265 = _103 - _73[_238];
                                float _266 = _265.x;
                                float _267 = _264.y;
                                float _269 = _265.y;
                                float _270 = _264.x;
                                float _273 = _263.y;
                                float _275 = _263.x;
                                float _277 = (_266 * _273) - (_269 * _275);
                                float _280 = (_275 * _267) - (_273 * _270);
                                bool _282 = abs(_280) < 0.001000000047497451305389404296875;
                                bool _284 = abs(_277) < 0.001000000047497451305389404296875;
                                bool _289;
                                if (_282)
                                {
                                    _289 = !_284;
                                }
                                else
                                {
                                    _289 = false;
                                }
                                if (_282 ? _284 : false)
                                {
                                    _319 = float2(0.0);
                                    _320 = false;
                                    break;
                                }
                                else
                                {
                                    if (_289)
                                    {
                                        _319 = float2(0.0);
                                        _320 = false;
                                        break;
                                    }
                                    else
                                    {
                                        if (!_282)
                                        {
                                            float _300 = ((_266 * _267) - (_269 * _270)) / _280;
                                            float _301 = _277 / _280;
                                            bool _306;
                                            if (_300 >= 0.0)
                                            {
                                                _306 = _300 <= 1.0;
                                            }
                                            else
                                            {
                                                _306 = false;
                                            }
                                            bool _314;
                                            if (_306)
                                            {
                                                bool _313;
                                                if (_301 >= 0.0)
                                                {
                                                    _313 = _301 <= 1.0;
                                                }
                                                else
                                                {
                                                    _313 = false;
                                                }
                                                _314 = _313;
                                            }
                                            else
                                            {
                                                _314 = false;
                                            }
                                            if (_314)
                                            {
                                                _319 = _103 + (_264 * _301);
                                                _320 = true;
                                                break;
                                            }
                                            _319 = float2(0.0);
                                            _320 = false;
                                            break;
                                        }
                                        else
                                        {
                                            _319 = float2(0.0);
                                            _320 = false;
                                            break;
                                        }
                                        break; // unreachable workaround
                                    }
                                    break; // unreachable workaround
                                }
                                break; // unreachable workaround
                            } while(false);
                            if (_320)
                            {
                                float _324 = length(_319 - _103);
                                _236 = (_324 < _125) ? _324 : _125;
                            }
                            else
                            {
                                _236 = _125;
                            }
                        }
                    }
                    _105 = _106;
                    _108++;
                    continue;
                }
                else
                {
                    break;
                }
            }
            RayDataBuffer._m0[_97].Length = _105;
        }
        break;
    } while(false);
}

