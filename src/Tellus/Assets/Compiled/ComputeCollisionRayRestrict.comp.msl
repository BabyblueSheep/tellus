#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct CollisionBodyPartData
{
    int CollisionBodyIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_CollisionBodyPartData
{
    CollisionBodyPartData _m0[1];
};

struct CollisionBodyData
{
    int BodyPartIndexStart;
    int BodyPartIndexLength;
    float2 Offset;
};

struct type_StructuredBuffer_CollisionBodyData
{
    CollisionBodyData _m0[1];
};

struct RayCasterData
{
    int RayIndexStart;
    int RayIndexLength;
    float2 Offset;
};

struct type_StructuredBuffer_RayCasterData
{
    RayCasterData _m0[1];
};

struct type_RWByteAddressBuffer
{
    uint _m0[1];
};

struct type_UniformBlock
{
    uint StoredBodyCount;
    uint StoredRayCasterCount;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_CollisionBodyPartData& BodyPartDataBuffer [[buffer(1)]], const device type_StructuredBuffer_CollisionBodyData& BodyDataBuffer [[buffer(2)]], const device type_StructuredBuffer_RayCasterData& RayCasterDataBuffer [[buffer(3)]], device type_RWByteAddressBuffer& RayDataBuffer [[buffer(4)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        bool _90;
        if (!(gl_GlobalInvocationID.x >= UniformBlock.StoredBodyCount))
        {
            _90 = gl_GlobalInvocationID.y >= UniformBlock.StoredRayCasterCount;
        }
        else
        {
            _90 = true;
        }
        if (_90)
        {
            break;
        }
        spvUnsafeArray<float2, 16> _74;
        for (int _104 = 0; _104 < RayCasterDataBuffer._m0[gl_GlobalInvocationID.y].RayIndexLength; _104++)
        {
            int _111 = (_104 + RayCasterDataBuffer._m0[gl_GlobalInvocationID.y].RayIndexStart) * 20;
            float2 _136 = float2(as_type<float>(RayDataBuffer._m0[uint(_111 + 8) >> 2u]), as_type<float>(RayDataBuffer._m0[uint(_111 + 12) >> 2u]));
            uint _139 = uint(_111 + 16) >> 2u;
            float _142 = as_type<float>(RayDataBuffer._m0[_139]);
            float2 _143 = float2(as_type<float>(RayDataBuffer._m0[uint(_111) >> 2u]), as_type<float>(RayDataBuffer._m0[uint(_111 + 4) >> 2u])) + RayCasterDataBuffer._m0[gl_GlobalInvocationID.y].Offset;
            float _145;
            _145 = _142;
            float _146;
            for (int _148 = 0; _148 < BodyDataBuffer._m0[gl_GlobalInvocationID.x].BodyPartIndexLength; _145 = _146, _148++)
            {
                uint _154 = uint(_148 + BodyDataBuffer._m0[gl_GlobalInvocationID.x].BodyPartIndexStart);
                for (int _164 = 0; _164 < 16; )
                {
                    _74[_164] = float2(0.0);
                    _164++;
                    continue;
                }
                int _249;
                if (BodyPartDataBuffer._m0[_154].ShapeType == 0)
                {
                    for (int _234 = 0; _234 < BodyPartDataBuffer._m0[_154].IntegerFields.x; )
                    {
                        float _242 = (6.283185482025146484375 * float(_234)) / float(BodyPartDataBuffer._m0[_154].IntegerFields.x);
                        _74[_234] = BodyPartDataBuffer._m0[_154].Center + (float2(cos(_242), sin(_242)) * BodyPartDataBuffer._m0[_154].DecimalFields.x);
                        _234++;
                        continue;
                    }
                    _249 = BodyPartDataBuffer._m0[_154].IntegerFields.x;
                }
                else
                {
                    int _230;
                    if (BodyPartDataBuffer._m0[_154].ShapeType == 1)
                    {
                        float _192 = sin(BodyPartDataBuffer._m0[_154].DecimalFields.x);
                        float _193 = cos(BodyPartDataBuffer._m0[_154].DecimalFields.x);
                        float _196 = BodyPartDataBuffer._m0[_154].DecimalFields.y * (-0.5);
                        float _197 = BodyPartDataBuffer._m0[_154].DecimalFields.z * (-0.5);
                        _74[0] = float2(_196, _197);
                        float _200 = BodyPartDataBuffer._m0[_154].DecimalFields.y * 0.5;
                        _74[1] = float2(_200, _197);
                        float _203 = BodyPartDataBuffer._m0[_154].DecimalFields.z * 0.5;
                        _74[2] = float2(_200, _203);
                        _74[3] = float2(_196, _203);
                        for (int _209 = 0; _209 < 4; )
                        {
                            float _223 = _74[_209].x;
                            float _225 = _74[_209].y;
                            _74[_209].x = (_74[_209].x * _193) + (_74[_209].y * (-_192));
                            _74[_209].y = (_223 * _192) + (_225 * _193);
                            _74[_209] += BodyPartDataBuffer._m0[_154].Center;
                            _209++;
                            continue;
                        }
                        _230 = 4;
                    }
                    else
                    {
                        bool _178 = BodyPartDataBuffer._m0[_154].ShapeType == 2;
                        if (_178)
                        {
                            _74[0] = BodyPartDataBuffer._m0[_154].Center;
                            _74[1] = float2(BodyPartDataBuffer._m0[_154].DecimalFields.xy);
                            _74[2] = float2(BodyPartDataBuffer._m0[_154].DecimalFields.zw);
                        }
                        _230 = _178 ? 3 : 1;
                    }
                    _249 = _230;
                }
                for (int _251 = 0; _251 < 16; )
                {
                    _74[_251] += BodyDataBuffer._m0[gl_GlobalInvocationID.x].Offset;
                    _251++;
                    continue;
                }
                _146 = _145;
                float _260;
                for (int _262 = 0; _262 < _249; _146 = _260, _262++)
                {
                    int _273;
                    if (_262 == (_249 - 1))
                    {
                        _273 = 0;
                    }
                    else
                    {
                        _273 = _262 + 1;
                    }
                    float2 _343;
                    bool _344;
                    do
                    {
                        float2 _287 = fast::normalize(_74[_273] - _74[_262]) * length(_74[_273] - _74[_262]);
                        float2 _288 = _136 * _142;
                        float2 _289 = _143 - _74[_262];
                        float _290 = _289.x;
                        float _291 = _288.y;
                        float _293 = _289.y;
                        float _294 = _288.x;
                        float _297 = _287.y;
                        float _299 = _287.x;
                        float _301 = (_290 * _297) - (_293 * _299);
                        float _304 = (_299 * _291) - (_297 * _294);
                        bool _306 = abs(_304) < 0.001000000047497451305389404296875;
                        bool _308 = abs(_301) < 0.001000000047497451305389404296875;
                        bool _313;
                        if (_306)
                        {
                            _313 = !_308;
                        }
                        else
                        {
                            _313 = false;
                        }
                        if (_306 ? _308 : false)
                        {
                            _343 = float2(0.0);
                            _344 = false;
                            break;
                        }
                        else
                        {
                            if (_313)
                            {
                                _343 = float2(0.0);
                                _344 = false;
                                break;
                            }
                            else
                            {
                                if (!_306)
                                {
                                    float _324 = ((_290 * _291) - (_293 * _294)) / _304;
                                    float _325 = _301 / _304;
                                    bool _330;
                                    if (_324 >= 0.0)
                                    {
                                        _330 = _324 <= 1.0;
                                    }
                                    else
                                    {
                                        _330 = false;
                                    }
                                    bool _338;
                                    if (_330)
                                    {
                                        bool _337;
                                        if (_325 >= 0.0)
                                        {
                                            _337 = _325 <= 1.0;
                                        }
                                        else
                                        {
                                            _337 = false;
                                        }
                                        _338 = _337;
                                    }
                                    else
                                    {
                                        _338 = false;
                                    }
                                    if (_338)
                                    {
                                        _343 = _143 + (_288 * _325);
                                        _344 = true;
                                        break;
                                    }
                                    _343 = float2(0.0);
                                    _344 = false;
                                    break;
                                }
                                else
                                {
                                    _343 = float2(0.0);
                                    _344 = false;
                                    break;
                                }
                                break; // unreachable workaround
                            }
                            break; // unreachable workaround
                        }
                        break; // unreachable workaround
                    } while(false);
                    if (_344)
                    {
                        float _348 = length(_343 - _143);
                        _260 = (_348 < _146) ? _348 : _146;
                    }
                    else
                    {
                        _260 = _146;
                    }
                }
            }
            RayDataBuffer._m0[_139] = as_type<uint>(_145);
        }
        break;
    } while(false);
}

