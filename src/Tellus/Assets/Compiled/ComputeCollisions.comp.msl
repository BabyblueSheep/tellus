#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>
#include <metal_atomic>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct ColliderShapeData
{
    int ColliderIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_ColliderShapeData
{
    ColliderShapeData _m0[1];
};

struct type_RWByteAddressBuffer
{
    uint _m0[1];
};

struct type_UniformBlock
{
    int ColliderShapeBufferOneLength;
    int ColliderShapeBufferTwoLength;
    int ColliderShapeResultBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferOne [[buffer(1)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferTwo [[buffer(2)]], device type_RWByteAddressBuffer& CollisionResultBuffer [[buffer(3)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        bool _81;
        if (!(gl_GlobalInvocationID.x >= uint(UniformBlock.ColliderShapeBufferOneLength)))
        {
            _81 = gl_GlobalInvocationID.y >= uint(UniformBlock.ColliderShapeBufferTwoLength);
        }
        else
        {
            _81 = true;
        }
        if (_81)
        {
            break;
        }
        spvUnsafeArray<float2, 16> _58;
        for (int _105 = 0; _105 < 16; )
        {
            _58[_105] = float2(0.0);
            _105++;
            continue;
        }
        int _176;
        if (ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 0)
        {
            for (int _118 = 0; _118 < ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x; )
            {
                float _126 = (6.283185482025146484375 * float(_118)) / float(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x);
                _58[_118] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center + (float2(cos(_126), sin(_126)) * ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                _118++;
                continue;
            }
            _176 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x;
        }
        else
        {
            bool _133 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 1;
            if (_133)
            {
                float _137 = sin(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                float _138 = cos(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                float _141 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.y * (-0.5);
                float _142 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.z * (-0.5);
                _58[0] = float2(_141, _142);
                float _145 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.y * 0.5;
                _58[1] = float2(_145, _142);
                float _148 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.z * 0.5;
                _58[2] = float2(_145, _148);
                _58[3] = float2(_141, _148);
                for (int _154 = 0; _154 < 4; )
                {
                    float _168 = _58[_154].x;
                    float _170 = _58[_154].y;
                    _58[_154].x = (_58[_154].x * _138) + (_58[_154].y * (-_137));
                    _58[_154].y = (_168 * _137) + (_170 * _138);
                    _58[_154] += ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center;
                    _154++;
                    continue;
                }
            }
            _176 = _133 ? 4 : 1;
        }
        spvUnsafeArray<float2, 16> _59;
        for (int _178 = 0; _178 < 16; )
        {
            _59[_178] = float2(0.0);
            _178++;
            continue;
        }
        int _249;
        if (ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 0)
        {
            for (int _191 = 0; _191 < ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x; )
            {
                float _199 = (6.283185482025146484375 * float(_191)) / float(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x);
                _59[_191] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center + (float2(cos(_199), sin(_199)) * ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                _191++;
                continue;
            }
            _249 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x;
        }
        else
        {
            bool _206 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 1;
            if (_206)
            {
                float _210 = sin(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                float _211 = cos(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                float _214 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.y * (-0.5);
                float _215 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.z * (-0.5);
                _59[0] = float2(_214, _215);
                float _218 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.y * 0.5;
                _59[1] = float2(_218, _215);
                float _221 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.z * 0.5;
                _59[2] = float2(_218, _221);
                _59[3] = float2(_214, _221);
                for (int _227 = 0; _227 < 4; )
                {
                    float _241 = _59[_227].x;
                    float _243 = _59[_227].y;
                    _59[_227].x = (_59[_227].x * _211) + (_59[_227].y * (-_210));
                    _59[_227].y = (_241 * _210) + (_243 * _211);
                    _59[_227] += ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center;
                    _227++;
                    continue;
                }
            }
            _249 = _206 ? 4 : 1;
        }
        bool _316;
        int _251 = 0;
        for (;;)
        {
            if (_251 < _176)
            {
                int _263;
                if (_251 == (_176 - 1))
                {
                    _263 = 0;
                }
                else
                {
                    _263 = _251 + 1;
                }
                float2 _268 = _58[_263] - _58[_251];
                float2 _273 = fast::normalize(float2(-_268.y, _268.x));
                spvUnsafeArray<float2, 16> _60 = _58;
                float _277 = dot(_60[0], _273);
                float _279;
                float _282;
                _279 = _277;
                _282 = _277;
                for (int _284 = 1; _284 < _176; )
                {
                    float _290 = dot(_60[_284], _273);
                    _279 = precise::max(_279, _290);
                    _282 = precise::min(_282, _290);
                    _284++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _61 = _59;
                float _294 = dot(_61[0], _273);
                float _296;
                float _299;
                _296 = _294;
                _299 = _294;
                for (int _301 = 1; _301 < _249; )
                {
                    float _307 = dot(_61[_301], _273);
                    _296 = precise::max(_296, _307);
                    _299 = precise::min(_299, _307);
                    _301++;
                    continue;
                }
                bool _312;
                if (_282 <= _296)
                {
                    _312 = _279 >= _299;
                }
                else
                {
                    _312 = false;
                }
                if (!_312)
                {
                    _316 = true;
                    break;
                }
                _251++;
                continue;
            }
            else
            {
                _316 = false;
                break;
            }
        }
        if (_316)
        {
            break;
        }
        bool _384;
        int _319 = 0;
        for (;;)
        {
            if (_319 < _249)
            {
                int _331;
                if (_319 == (_249 - 1))
                {
                    _331 = 0;
                }
                else
                {
                    _331 = _319 + 1;
                }
                float2 _336 = _59[_331] - _59[_319];
                float2 _341 = fast::normalize(float2(-_336.y, _336.x));
                spvUnsafeArray<float2, 16> _62 = _58;
                float _345 = dot(_62[0], _341);
                float _347;
                float _350;
                _347 = _345;
                _350 = _345;
                for (int _352 = 1; _352 < _176; )
                {
                    float _358 = dot(_62[_352], _341);
                    _347 = precise::max(_347, _358);
                    _350 = precise::min(_350, _358);
                    _352++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _63 = _59;
                float _362 = dot(_63[0], _341);
                float _364;
                float _367;
                _364 = _362;
                _367 = _362;
                for (int _369 = 1; _369 < _249; )
                {
                    float _375 = dot(_63[_369], _341);
                    _364 = precise::max(_364, _375);
                    _367 = precise::min(_367, _375);
                    _369++;
                    continue;
                }
                bool _380;
                if (_350 <= _364)
                {
                    _380 = _347 >= _367;
                }
                else
                {
                    _380 = false;
                }
                if (!_380)
                {
                    _384 = true;
                    break;
                }
                _319++;
                continue;
            }
            else
            {
                _384 = _316;
                break;
            }
        }
        if (_384)
        {
            break;
        }
        uint _394 = atomic_fetch_add_explicit((device atomic_uint*)&CollisionResultBuffer._m0[(uint((ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ColliderIndex * UniformBlock.ColliderShapeResultBufferLength) + ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ColliderIndex) * 4u) >> 2u], 1u, memory_order_relaxed);
        break;
    } while(false);
}

