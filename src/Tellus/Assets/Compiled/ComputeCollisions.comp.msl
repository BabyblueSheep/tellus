#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>
#include <metal_atomic>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct ColliderShapeData
{
    int ColliderIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_ColliderShapeData
{
    ColliderShapeData _m0[1];
};

struct type_RWByteAddressBuffer
{
    uint _m0[1];
};

struct type_UniformBlock
{
    int ColliderShapeBufferOneLength;
    int ColliderShapeBufferTwoLength;
    int ColliderShapeResultBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferOne [[buffer(1)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferTwo [[buffer(2)]], device type_RWByteAddressBuffer& CollisionResultBuffer [[buffer(3)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        bool _81;
        if (!(gl_GlobalInvocationID.x >= uint(UniformBlock.ColliderShapeBufferOneLength)))
        {
            _81 = gl_GlobalInvocationID.y >= uint(UniformBlock.ColliderShapeBufferTwoLength);
        }
        else
        {
            _81 = true;
        }
        if (_81)
        {
            break;
        }
        spvUnsafeArray<float2, 16> _58;
        for (int _105 = 0; _105 < 16; )
        {
            _58[_105] = float2(0.0);
            _105++;
            continue;
        }
        int _190;
        if (ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 0)
        {
            for (int _118 = 0; _118 < ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x; )
            {
                float _126 = (6.283185482025146484375 * float(_118)) / float(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x);
                _58[_118] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center + (float2(cos(_126), sin(_126)) * ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                _118++;
                continue;
            }
            _190 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x;
        }
        else
        {
            int _189;
            if (ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 1)
            {
                float _138 = sin(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                float _139 = cos(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                float _142 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.y * (-0.5);
                float _143 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.z * (-0.5);
                _58[0] = float2(_142, _143);
                float _146 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.y * 0.5;
                _58[1] = float2(_146, _143);
                float _149 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.z * 0.5;
                _58[2] = float2(_146, _149);
                _58[3] = float2(_142, _149);
                for (int _155 = 0; _155 < 4; )
                {
                    float _169 = _58[_155].x;
                    float _171 = _58[_155].y;
                    _58[_155].x = (_58[_155].x * _139) + (_58[_155].y * (-_138));
                    _58[_155].y = (_169 * _138) + (_171 * _139);
                    _58[_155] += ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center;
                    _155++;
                    continue;
                }
                _189 = 4;
            }
            else
            {
                bool _176 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 2;
                if (_176)
                {
                    _58[0] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center;
                    _58[1] = float2(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.xy);
                    _58[2] = float2(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.zw);
                }
                _189 = _176 ? 3 : 1;
            }
            _190 = _189;
        }
        spvUnsafeArray<float2, 16> _59;
        for (int _192 = 0; _192 < 16; )
        {
            _59[_192] = float2(0.0);
            _192++;
            continue;
        }
        int _277;
        if (ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 0)
        {
            for (int _205 = 0; _205 < ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x; )
            {
                float _213 = (6.283185482025146484375 * float(_205)) / float(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x);
                _59[_205] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center + (float2(cos(_213), sin(_213)) * ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                _205++;
                continue;
            }
            _277 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x;
        }
        else
        {
            int _276;
            if (ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 1)
            {
                float _225 = sin(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                float _226 = cos(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                float _229 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.y * (-0.5);
                float _230 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.z * (-0.5);
                _59[0] = float2(_229, _230);
                float _233 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.y * 0.5;
                _59[1] = float2(_233, _230);
                float _236 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.z * 0.5;
                _59[2] = float2(_233, _236);
                _59[3] = float2(_229, _236);
                for (int _242 = 0; _242 < 4; )
                {
                    float _256 = _59[_242].x;
                    float _258 = _59[_242].y;
                    _59[_242].x = (_59[_242].x * _226) + (_59[_242].y * (-_225));
                    _59[_242].y = (_256 * _225) + (_258 * _226);
                    _59[_242] += ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center;
                    _242++;
                    continue;
                }
                _276 = 4;
            }
            else
            {
                bool _263 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 2;
                if (_263)
                {
                    _59[0] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center;
                    _59[1] = float2(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.xy);
                    _59[2] = float2(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.zw);
                }
                _276 = _263 ? 3 : 1;
            }
            _277 = _276;
        }
        bool _344;
        int _279 = 0;
        for (;;)
        {
            if (_279 < _190)
            {
                int _291;
                if (_279 == (_190 - 1))
                {
                    _291 = 0;
                }
                else
                {
                    _291 = _279 + 1;
                }
                float2 _296 = _58[_291] - _58[_279];
                float2 _301 = fast::normalize(float2(-_296.y, _296.x));
                spvUnsafeArray<float2, 16> _60 = _58;
                float _305 = dot(_60[0], _301);
                float _307;
                float _310;
                _307 = _305;
                _310 = _305;
                for (int _312 = 1; _312 < _190; )
                {
                    float _318 = dot(_60[_312], _301);
                    _307 = precise::max(_307, _318);
                    _310 = precise::min(_310, _318);
                    _312++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _61 = _59;
                float _322 = dot(_61[0], _301);
                float _324;
                float _327;
                _324 = _322;
                _327 = _322;
                for (int _329 = 1; _329 < _277; )
                {
                    float _335 = dot(_61[_329], _301);
                    _324 = precise::max(_324, _335);
                    _327 = precise::min(_327, _335);
                    _329++;
                    continue;
                }
                bool _340;
                if (_310 <= _324)
                {
                    _340 = _307 >= _327;
                }
                else
                {
                    _340 = false;
                }
                if (!_340)
                {
                    _344 = true;
                    break;
                }
                _279++;
                continue;
            }
            else
            {
                _344 = false;
                break;
            }
        }
        if (_344)
        {
            break;
        }
        bool _412;
        int _347 = 0;
        for (;;)
        {
            if (_347 < _277)
            {
                int _359;
                if (_347 == (_277 - 1))
                {
                    _359 = 0;
                }
                else
                {
                    _359 = _347 + 1;
                }
                float2 _364 = _59[_359] - _59[_347];
                float2 _369 = fast::normalize(float2(-_364.y, _364.x));
                spvUnsafeArray<float2, 16> _62 = _58;
                float _373 = dot(_62[0], _369);
                float _375;
                float _378;
                _375 = _373;
                _378 = _373;
                for (int _380 = 1; _380 < _190; )
                {
                    float _386 = dot(_62[_380], _369);
                    _375 = precise::max(_375, _386);
                    _378 = precise::min(_378, _386);
                    _380++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _63 = _59;
                float _390 = dot(_63[0], _369);
                float _392;
                float _395;
                _392 = _390;
                _395 = _390;
                for (int _397 = 1; _397 < _277; )
                {
                    float _403 = dot(_63[_397], _369);
                    _392 = precise::max(_392, _403);
                    _395 = precise::min(_395, _403);
                    _397++;
                    continue;
                }
                bool _408;
                if (_378 <= _392)
                {
                    _408 = _375 >= _395;
                }
                else
                {
                    _408 = false;
                }
                if (!_408)
                {
                    _412 = true;
                    break;
                }
                _347++;
                continue;
            }
            else
            {
                _412 = _344;
                break;
            }
        }
        if (_412)
        {
            break;
        }
        uint _422 = atomic_fetch_add_explicit((device atomic_uint*)&CollisionResultBuffer._m0[(uint((ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ColliderIndex * UniformBlock.ColliderShapeResultBufferLength) + ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ColliderIndex) * 4u) >> 2u], 1u, memory_order_relaxed);
        break;
    } while(false);
}

