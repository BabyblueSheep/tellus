#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>
#include <metal_atomic>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct ColliderShapeData
{
    int ColliderIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_ColliderShapeData
{
    ColliderShapeData _m0[1];
};

struct type_RWByteAddressBuffer
{
    uint _m0[1];
};

struct type_UniformBlock
{
    int ColliderShapeBufferOneLength;
    int ColliderShapeBufferTwoLength;
    int ColliderShapeResultBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferOne [[buffer(1)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferTwo [[buffer(2)]], device type_RWByteAddressBuffer& CollisionResultBuffer [[buffer(3)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        bool _81;
        if (!(gl_GlobalInvocationID.x >= uint(UniformBlock.ColliderShapeBufferOneLength)))
        {
            _81 = gl_GlobalInvocationID.y >= uint(UniformBlock.ColliderShapeBufferTwoLength);
        }
        else
        {
            _81 = true;
        }
        if (_81)
        {
            break;
        }
        spvUnsafeArray<float2, 16> _58;
        for (int _101 = 0; _101 < 16; )
        {
            _58[_101] = float2(0.0);
            _101++;
            continue;
        }
        int _196;
        if (ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 0)
        {
            for (int _114 = 0; _114 < ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x; )
            {
                float _122 = (6.283185482025146484375 * float(_114)) / float(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x);
                _58[_114] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center + (float2(cos(_122), sin(_122)) * ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                _114++;
                continue;
            }
            _196 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].IntegerFields.x;
        }
        else
        {
            int _195;
            if (ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 1)
            {
                float _134 = sin(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                float _135 = cos(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.x);
                float _138 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.y * (-0.5);
                float _139 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.z * (-0.5);
                _58[0] = float2(_138, _139);
                float _142 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.y * 0.5;
                _58[1] = float2(_142, _139);
                float _145 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.z * 0.5;
                _58[2] = float2(_142, _145);
                _58[3] = float2(_138, _145);
                for (int _151 = 0; _151 < 4; )
                {
                    float _165 = _58[_151].x;
                    float _167 = _58[_151].y;
                    _58[_151].x = (_58[_151].x * _135) + (_58[_151].y * (-_134));
                    _58[_151].y = (_165 * _134) + (_167 * _135);
                    _58[_151] += ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center;
                    _151++;
                    continue;
                }
                _195 = 4;
            }
            else
            {
                int _194;
                if (ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 2)
                {
                    _58[0] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center;
                    _58[1] = float2(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.xy);
                    _58[2] = float2(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.zw);
                    _194 = 3;
                }
                else
                {
                    bool _185 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 3;
                    if (_185)
                    {
                        _58[0] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center;
                        _58[1] = float2(ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].DecimalFields.xy);
                    }
                    _194 = _185 ? 2 : 1;
                }
                _195 = _194;
            }
            _196 = _195;
        }
        spvUnsafeArray<float2, 16> _59;
        for (int _198 = 0; _198 < 16; )
        {
            _59[_198] = float2(0.0);
            _198++;
            continue;
        }
        int _293;
        if (ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 0)
        {
            for (int _211 = 0; _211 < ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x; )
            {
                float _219 = (6.283185482025146484375 * float(_211)) / float(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x);
                _59[_211] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center + (float2(cos(_219), sin(_219)) * ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                _211++;
                continue;
            }
            _293 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].IntegerFields.x;
        }
        else
        {
            int _292;
            if (ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 1)
            {
                float _231 = sin(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                float _232 = cos(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.x);
                float _235 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.y * (-0.5);
                float _236 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.z * (-0.5);
                _59[0] = float2(_235, _236);
                float _239 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.y * 0.5;
                _59[1] = float2(_239, _236);
                float _242 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.z * 0.5;
                _59[2] = float2(_239, _242);
                _59[3] = float2(_235, _242);
                for (int _248 = 0; _248 < 4; )
                {
                    float _262 = _59[_248].x;
                    float _264 = _59[_248].y;
                    _59[_248].x = (_59[_248].x * _232) + (_59[_248].y * (-_231));
                    _59[_248].y = (_262 * _231) + (_264 * _232);
                    _59[_248] += ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center;
                    _248++;
                    continue;
                }
                _292 = 4;
            }
            else
            {
                int _291;
                if (ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 2)
                {
                    _59[0] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center;
                    _59[1] = float2(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.xy);
                    _59[2] = float2(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.zw);
                    _291 = 3;
                }
                else
                {
                    bool _282 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 3;
                    if (_282)
                    {
                        _59[0] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center;
                        _59[1] = float2(ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].DecimalFields.xy);
                    }
                    _291 = _282 ? 2 : 1;
                }
                _292 = _291;
            }
            _293 = _292;
        }
        bool _360;
        int _295 = 0;
        for (;;)
        {
            if (_295 < _196)
            {
                int _307;
                if (_295 == (_196 - 1))
                {
                    _307 = 0;
                }
                else
                {
                    _307 = _295 + 1;
                }
                float2 _312 = _58[_307] - _58[_295];
                float2 _317 = fast::normalize(float2(-_312.y, _312.x));
                spvUnsafeArray<float2, 16> _60 = _58;
                float _321 = dot(_60[0], _317);
                float _323;
                float _326;
                _323 = _321;
                _326 = _321;
                for (int _328 = 1; _328 < _196; )
                {
                    float _334 = dot(_60[_328], _317);
                    _323 = precise::max(_323, _334);
                    _326 = precise::min(_326, _334);
                    _328++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _61 = _59;
                float _338 = dot(_61[0], _317);
                float _340;
                float _343;
                _340 = _338;
                _343 = _338;
                for (int _345 = 1; _345 < _293; )
                {
                    float _351 = dot(_61[_345], _317);
                    _340 = precise::max(_340, _351);
                    _343 = precise::min(_343, _351);
                    _345++;
                    continue;
                }
                bool _356;
                if (_326 <= _340)
                {
                    _356 = _323 >= _343;
                }
                else
                {
                    _356 = false;
                }
                if (!_356)
                {
                    _360 = true;
                    break;
                }
                _295++;
                continue;
            }
            else
            {
                _360 = false;
                break;
            }
        }
        if (_360)
        {
            break;
        }
        bool _428;
        int _363 = 0;
        for (;;)
        {
            if (_363 < _293)
            {
                int _375;
                if (_363 == (_293 - 1))
                {
                    _375 = 0;
                }
                else
                {
                    _375 = _363 + 1;
                }
                float2 _380 = _59[_375] - _59[_363];
                float2 _385 = fast::normalize(float2(-_380.y, _380.x));
                spvUnsafeArray<float2, 16> _62 = _58;
                float _389 = dot(_62[0], _385);
                float _391;
                float _394;
                _391 = _389;
                _394 = _389;
                for (int _396 = 1; _396 < _196; )
                {
                    float _402 = dot(_62[_396], _385);
                    _391 = precise::max(_391, _402);
                    _394 = precise::min(_394, _402);
                    _396++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _63 = _59;
                float _406 = dot(_63[0], _385);
                float _408;
                float _411;
                _408 = _406;
                _411 = _406;
                for (int _413 = 1; _413 < _293; )
                {
                    float _419 = dot(_63[_413], _385);
                    _408 = precise::max(_408, _419);
                    _411 = precise::min(_411, _419);
                    _413++;
                    continue;
                }
                bool _424;
                if (_394 <= _408)
                {
                    _424 = _391 >= _411;
                }
                else
                {
                    _424 = false;
                }
                if (!_424)
                {
                    _428 = true;
                    break;
                }
                _363++;
                continue;
            }
            else
            {
                _428 = _360;
                break;
            }
        }
        if (_428)
        {
            break;
        }
        uint _431 = atomic_fetch_add_explicit((device atomic_uint*)&CollisionResultBuffer._m0[0u], 1u, memory_order_relaxed);
        uint _438 = atomic_fetch_add_explicit((device atomic_uint*)&CollisionResultBuffer._m0[uint(4 + (int(_431) * 4)) >> 2u], 1u, memory_order_relaxed);
        break;
    } while(false);
}

