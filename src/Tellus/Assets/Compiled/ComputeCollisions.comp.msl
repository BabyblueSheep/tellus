#pragma clang diagnostic ignored "-Wunused-variable"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>
#include <metal_atomic>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct ColliderShapeData
{
    int ColliderIndex;
    int ShapeType;
    float2 Center;
    float4 Fields;
};

struct type_StructuredBuffer_ColliderShapeData
{
    ColliderShapeData _m0[1];
};

struct type_RWByteAddressBuffer
{
    uint _m0[1];
};

struct type_UniformBlock
{
    int ColliderShapeBufferOneLength;
    int ColliderShapeBufferTwoLength;
    int ColliderShapeResultBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferOne [[buffer(1)]], const device type_StructuredBuffer_ColliderShapeData& ShapeDataBufferTwo [[buffer(2)]], device type_RWByteAddressBuffer& CollisionResultBuffer [[buffer(3)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        bool _73;
        if (!(gl_GlobalInvocationID.x >= uint(UniformBlock.ColliderShapeBufferOneLength)))
        {
            _73 = gl_GlobalInvocationID.y >= uint(UniformBlock.ColliderShapeBufferTwoLength);
        }
        else
        {
            _73 = true;
        }
        if (_73)
        {
            break;
        }
        spvUnsafeArray<float2, 16> _50;
        for (int _89 = 0; _89 < 16; )
        {
            _50[_89] = float2(0.0);
            _89++;
            continue;
        }
        bool _95 = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ShapeType == 0;
        if (_95)
        {
            for (int _100 = 0; _100 < 12; )
            {
                float _106 = float(_100) * 0.52359879016876220703125;
                _50[_100] = ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Center + (float2(cos(_106), sin(_106)) * ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].Fields.x);
                _100++;
                continue;
            }
        }
        int _113 = _95 ? 12 : 1;
        spvUnsafeArray<float2, 16> _51;
        for (int _115 = 0; _115 < 16; )
        {
            _51[_115] = float2(0.0);
            _115++;
            continue;
        }
        bool _121 = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ShapeType == 0;
        if (_121)
        {
            for (int _126 = 0; _126 < 12; )
            {
                float _132 = float(_126) * 0.52359879016876220703125;
                _51[_126] = ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Center + (float2(cos(_132), sin(_132)) * ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].Fields.x);
                _126++;
                continue;
            }
        }
        int _139 = _121 ? 12 : 1;
        bool _206;
        int _141 = 0;
        for (;;)
        {
            if (_141 < _113)
            {
                int _153;
                if (_141 == (_113 - 1))
                {
                    _153 = 0;
                }
                else
                {
                    _153 = _141 + 1;
                }
                float2 _158 = _50[_153] - _50[_141];
                float2 _163 = fast::normalize(float2(-_158.y, _158.x));
                spvUnsafeArray<float2, 16> _52 = _50;
                float _167 = dot(_52[0], _163);
                float _169;
                float _172;
                _169 = _167;
                _172 = _167;
                for (int _174 = 1; _174 < _113; )
                {
                    float _180 = dot(_52[_174], _163);
                    _169 = precise::max(_169, _180);
                    _172 = precise::min(_172, _180);
                    _174++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _53 = _51;
                float _184 = dot(_53[0], _163);
                float _186;
                float _189;
                _186 = _184;
                _189 = _184;
                for (int _191 = 1; _191 < _139; )
                {
                    float _197 = dot(_53[_191], _163);
                    _186 = precise::max(_186, _197);
                    _189 = precise::min(_189, _197);
                    _191++;
                    continue;
                }
                bool _202;
                if (_172 <= _186)
                {
                    _202 = _169 >= _189;
                }
                else
                {
                    _202 = false;
                }
                if (!_202)
                {
                    _206 = true;
                    break;
                }
                _141++;
                continue;
            }
            else
            {
                _206 = false;
                break;
            }
        }
        if (_206)
        {
            break;
        }
        bool _274;
        int _209 = 0;
        for (;;)
        {
            if (_209 < _139)
            {
                int _221;
                if (_209 == (_139 - 1))
                {
                    _221 = 0;
                }
                else
                {
                    _221 = _209 + 1;
                }
                float2 _226 = _51[_221] - _51[_209];
                float2 _231 = fast::normalize(float2(-_226.y, _226.x));
                spvUnsafeArray<float2, 16> _54 = _50;
                float _235 = dot(_54[0], _231);
                float _237;
                float _240;
                _237 = _235;
                _240 = _235;
                for (int _242 = 1; _242 < _113; )
                {
                    float _248 = dot(_54[_242], _231);
                    _237 = precise::max(_237, _248);
                    _240 = precise::min(_240, _248);
                    _242++;
                    continue;
                }
                spvUnsafeArray<float2, 16> _55 = _51;
                float _252 = dot(_55[0], _231);
                float _254;
                float _257;
                _254 = _252;
                _257 = _252;
                for (int _259 = 1; _259 < _139; )
                {
                    float _265 = dot(_55[_259], _231);
                    _254 = precise::max(_254, _265);
                    _257 = precise::min(_257, _265);
                    _259++;
                    continue;
                }
                bool _270;
                if (_240 <= _254)
                {
                    _270 = _237 >= _257;
                }
                else
                {
                    _270 = false;
                }
                if (!_270)
                {
                    _274 = true;
                    break;
                }
                _209++;
                continue;
            }
            else
            {
                _274 = _206;
                break;
            }
        }
        if (_274)
        {
            break;
        }
        uint _284 = atomic_fetch_add_explicit((device atomic_uint*)&CollisionResultBuffer._m0[(uint((ShapeDataBufferTwo._m0[gl_GlobalInvocationID.y].ColliderIndex * UniformBlock.ColliderShapeResultBufferLength) + ShapeDataBufferOne._m0[gl_GlobalInvocationID.x].ColliderIndex) * 4u) >> 2u], 1u, memory_order_relaxed);
        break;
    } while(false);
}

