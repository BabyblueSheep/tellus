#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct CollisionBodyPartData
{
    int CollisionBodyIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_CollisionBodyPartData
{
    CollisionBodyPartData _m0[1];
};

struct CollisionBodyData
{
    int BodyPartIndexStart;
    int BodyPartIndexLength;
    float2 Offset;
};

struct type_StructuredBuffer_CollisionBodyData
{
    CollisionBodyData _m0[1];
};

struct LineCollectionData
{
    int LineIndexStart;
    int LineIndexLength;
    float2 Offset;
    int LineVelocityIndex;
    int Padding;
};

struct type_StructuredBuffer_LineCollectionData
{
    LineCollectionData _m0[1];
};

struct LineData
{
    float2 Origin;
    float2 Vector;
    float Length;
    int Flags;
};

struct type_RWStructuredBuffer_LineData
{
    LineData _m0[1];
};

struct type_UniformBlock
{
    int BodyDataBufferStartIndex;
    int BodyDataBufferLength;
    int LineCollectionDataBufferStartIndex;
    int LineCollectionDataBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_CollisionBodyPartData& BodyPartDataBuffer [[buffer(1)]], const device type_StructuredBuffer_CollisionBodyData& BodyDataBuffer [[buffer(2)]], const device type_StructuredBuffer_LineCollectionData& LineCollectionDataBuffer [[buffer(3)]], device type_RWStructuredBuffer_LineData& LineDataBuffer [[buffer(4)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        if (gl_GlobalInvocationID.x >= uint(UniformBlock.LineCollectionDataBufferLength))
        {
            break;
        }
        uint _86 = gl_GlobalInvocationID.x + uint(UniformBlock.LineCollectionDataBufferStartIndex);
        spvUnsafeArray<float2, 16> _72;
        for (int _92 = 0; _92 < LineCollectionDataBuffer._m0[_86].LineIndexLength; _92++)
        {
            uint _99 = uint(_92 + LineCollectionDataBuffer._m0[_86].LineIndexLength);
            if ((LineDataBuffer._m0[_99].Flags & 1) == 0)
            {
                continue;
            }
            float2 _110 = LineDataBuffer._m0[_99].Origin + LineCollectionDataBuffer._m0[_86].Offset;
            float2 _118;
            if ((LineDataBuffer._m0[_99].Flags & 2) == 2)
            {
                _118 = LineDataBuffer._m0[_99].Vector;
            }
            else
            {
                _118 = _110 + (LineDataBuffer._m0[_99].Vector * LineDataBuffer._m0[_99].Length);
            }
            float _120;
            _120 = LineDataBuffer._m0[_99].Length;
            float _121;
            for (int _123 = 0; _123 < UniformBlock.BodyDataBufferLength; _120 = _121, _123++)
            {
                uint _133 = uint(_123 + UniformBlock.BodyDataBufferStartIndex);
                _121 = _120;
                float _143;
                for (int _140 = 0; _140 < BodyDataBuffer._m0[_133].BodyPartIndexLength; _140++, _121 = _143)
                {
                    uint _148 = uint(_140 + BodyDataBuffer._m0[_133].BodyPartIndexStart);
                    for (int _158 = 0; _158 < 16; )
                    {
                        _72[_158] = float2(0.0);
                        _158++;
                        continue;
                    }
                    int _243;
                    if (BodyPartDataBuffer._m0[_148].ShapeType == 0)
                    {
                        for (int _228 = 0; _228 < BodyPartDataBuffer._m0[_148].IntegerFields.x; )
                        {
                            float _236 = (6.283185482025146484375 * float(_228)) / float(BodyPartDataBuffer._m0[_148].IntegerFields.x);
                            _72[_228] = BodyPartDataBuffer._m0[_148].Center + (float2(cos(_236), sin(_236)) * BodyPartDataBuffer._m0[_148].DecimalFields.x);
                            _228++;
                            continue;
                        }
                        _243 = BodyPartDataBuffer._m0[_148].IntegerFields.x;
                    }
                    else
                    {
                        int _224;
                        if (BodyPartDataBuffer._m0[_148].ShapeType == 1)
                        {
                            float _186 = sin(BodyPartDataBuffer._m0[_148].DecimalFields.x);
                            float _187 = cos(BodyPartDataBuffer._m0[_148].DecimalFields.x);
                            float _190 = BodyPartDataBuffer._m0[_148].DecimalFields.y * (-0.5);
                            float _191 = BodyPartDataBuffer._m0[_148].DecimalFields.z * (-0.5);
                            _72[0] = float2(_190, _191);
                            float _194 = BodyPartDataBuffer._m0[_148].DecimalFields.y * 0.5;
                            _72[1] = float2(_194, _191);
                            float _197 = BodyPartDataBuffer._m0[_148].DecimalFields.z * 0.5;
                            _72[2] = float2(_194, _197);
                            _72[3] = float2(_190, _197);
                            for (int _203 = 0; _203 < 4; )
                            {
                                float _217 = _72[_203].x;
                                float _219 = _72[_203].y;
                                _72[_203].x = (_72[_203].x * _187) + (_72[_203].y * (-_186));
                                _72[_203].y = (_217 * _186) + (_219 * _187);
                                _72[_203] += BodyPartDataBuffer._m0[_148].Center;
                                _203++;
                                continue;
                            }
                            _224 = 4;
                        }
                        else
                        {
                            bool _172 = BodyPartDataBuffer._m0[_148].ShapeType == 2;
                            if (_172)
                            {
                                _72[0] = BodyPartDataBuffer._m0[_148].Center;
                                _72[1] = float2(BodyPartDataBuffer._m0[_148].DecimalFields.xy);
                                _72[2] = float2(BodyPartDataBuffer._m0[_148].DecimalFields.zw);
                            }
                            _224 = _172 ? 3 : 1;
                        }
                        _243 = _224;
                    }
                    for (int _245 = 0; _245 < 16; )
                    {
                        _72[_245] += BodyDataBuffer._m0[_133].Offset;
                        _245++;
                        continue;
                    }
                    _143 = _121;
                    float _254;
                    for (int _256 = 0; _256 < _243; _143 = _254, _256++)
                    {
                        int _267;
                        if (_256 == (_243 - 1))
                        {
                            _267 = 0;
                        }
                        else
                        {
                            _267 = _256 + 1;
                        }
                        float4 _276 = float4(_72[_256], _72[_267]);
                        float4 _281 = float4(_110, _118);
                        float2 _344;
                        bool _345;
                        do
                        {
                            float2 _285 = _276.xy;
                            float2 _286 = _276.zw - _285;
                            float2 _287 = _281.zw;
                            float2 _288 = _281.xy;
                            float2 _289 = _287 - _288;
                            float2 _290 = _288 - _285;
                            float _291 = _290.x;
                            float _292 = _289.y;
                            float _294 = _290.y;
                            float _295 = _289.x;
                            float _298 = _286.y;
                            float _300 = _286.x;
                            float _302 = (_291 * _298) - (_294 * _300);
                            float _305 = (_300 * _292) - (_298 * _295);
                            bool _307 = abs(_305) < 0.001000000047497451305389404296875;
                            bool _309 = abs(_302) < 0.001000000047497451305389404296875;
                            bool _314;
                            if (_307)
                            {
                                _314 = !_309;
                            }
                            else
                            {
                                _314 = false;
                            }
                            if (_307 ? _309 : false)
                            {
                                _344 = float2(0.0);
                                _345 = false;
                                break;
                            }
                            else
                            {
                                if (_314)
                                {
                                    _344 = float2(0.0);
                                    _345 = false;
                                    break;
                                }
                                else
                                {
                                    if (!_307)
                                    {
                                        float _325 = ((_291 * _292) - (_294 * _295)) / _305;
                                        float _326 = _302 / _305;
                                        bool _331;
                                        if (_325 >= 0.0)
                                        {
                                            _331 = _325 <= 1.0;
                                        }
                                        else
                                        {
                                            _331 = false;
                                        }
                                        bool _339;
                                        if (_331)
                                        {
                                            bool _338;
                                            if (_326 >= 0.0)
                                            {
                                                _338 = _326 <= 1.0;
                                            }
                                            else
                                            {
                                                _338 = false;
                                            }
                                            _339 = _338;
                                        }
                                        else
                                        {
                                            _339 = false;
                                        }
                                        if (_339)
                                        {
                                            _344 = mix(_288, _287, float2(_326));
                                            _345 = true;
                                            break;
                                        }
                                        _344 = float2(0.0);
                                        _345 = false;
                                        break;
                                    }
                                    else
                                    {
                                        _344 = float2(0.0);
                                        _345 = false;
                                        break;
                                    }
                                    break; // unreachable workaround
                                }
                                break; // unreachable workaround
                            }
                            break; // unreachable workaround
                        } while(false);
                        if (_345)
                        {
                            float _349 = length(_344 - _110);
                            _254 = (_349 < _143) ? _349 : _143;
                        }
                        else
                        {
                            _254 = _143;
                        }
                    }
                }
            }
            LineDataBuffer._m0[_99].Length = _120;
        }
        break;
    } while(false);
}

