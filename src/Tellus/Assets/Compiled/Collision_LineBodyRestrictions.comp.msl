#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wmissing-braces"

#include <metal_stdlib>
#include <simd/simd.h>

using namespace metal;

template<typename T, size_t Num>
struct spvUnsafeArray
{
    T elements[Num ? Num : 1];
    
    thread T& operator [] (size_t pos) thread
    {
        return elements[pos];
    }
    constexpr const thread T& operator [] (size_t pos) const thread
    {
        return elements[pos];
    }
    
    device T& operator [] (size_t pos) device
    {
        return elements[pos];
    }
    constexpr const device T& operator [] (size_t pos) const device
    {
        return elements[pos];
    }
    
    constexpr const constant T& operator [] (size_t pos) const constant
    {
        return elements[pos];
    }
    
    threadgroup T& operator [] (size_t pos) threadgroup
    {
        return elements[pos];
    }
    constexpr const threadgroup T& operator [] (size_t pos) const threadgroup
    {
        return elements[pos];
    }
};

struct CollisionBodyPartData
{
    int CollisionBodyIndex;
    int ShapeType;
    float2 Center;
    float4 DecimalFields;
    int2 IntegerFields;
    int Padding1;
    int Padding2;
};

struct type_StructuredBuffer_CollisionBodyPartData
{
    CollisionBodyPartData _m0[1];
};

struct CollisionBodyData
{
    int BodyPartIndexStart;
    int BodyPartIndexLength;
    float2 Offset;
};

struct type_StructuredBuffer_CollisionBodyData
{
    CollisionBodyData _m0[1];
};

struct LineCollectionData
{
    int LineIndexStart;
    int LineIndexLength;
    float2 Offset;
    int LineVelocityIndex;
    int Padding;
};

struct type_StructuredBuffer_LineCollectionData
{
    LineCollectionData _m0[1];
};

struct LineData
{
    float2 Origin;
    float2 Vector;
    float Length;
    int Flags;
};

struct type_RWStructuredBuffer_LineData
{
    LineData _m0[1];
};

struct type_UniformBlock
{
    int BodyDataBufferStartIndex;
    int BodyDataBufferLength;
    int LineCollectionDataBufferStartIndex;
    int LineCollectionDataBufferLength;
};

kernel void main0(constant type_UniformBlock& UniformBlock [[buffer(0)]], const device type_StructuredBuffer_CollisionBodyPartData& BodyPartDataBuffer [[buffer(1)]], const device type_StructuredBuffer_CollisionBodyData& BodyDataBuffer [[buffer(2)]], const device type_StructuredBuffer_LineCollectionData& LineCollectionDataBuffer [[buffer(3)]], device type_RWStructuredBuffer_LineData& LineDataBuffer [[buffer(4)]], uint3 gl_GlobalInvocationID [[thread_position_in_grid]])
{
    do
    {
        if (gl_GlobalInvocationID.x >= uint(UniformBlock.LineCollectionDataBufferLength))
        {
            break;
        }
        uint _86 = gl_GlobalInvocationID.x + uint(UniformBlock.LineCollectionDataBufferStartIndex);
        spvUnsafeArray<float2, 16> _72;
        for (int _92 = 0; _92 < LineCollectionDataBuffer._m0[_86].LineIndexLength; _92++)
        {
            uint _99 = uint(_92 + LineCollectionDataBuffer._m0[_86].LineIndexLength);
            if ((LineDataBuffer._m0[_99].Flags & 1) == 0)
            {
                continue;
            }
            float2 _110 = LineDataBuffer._m0[_99].Origin + LineCollectionDataBuffer._m0[_86].Offset;
            float2 _122;
            if ((LineDataBuffer._m0[_99].Flags & 2) == 2)
            {
                _122 = _110 + (fast::normalize(LineDataBuffer._m0[_99].Vector - _110) * LineDataBuffer._m0[_99].Length);
            }
            else
            {
                _122 = _110 + (LineDataBuffer._m0[_99].Vector * LineDataBuffer._m0[_99].Length);
            }
            float _124;
            _124 = LineDataBuffer._m0[_99].Length;
            float _125;
            for (int _127 = 0; _127 < UniformBlock.BodyDataBufferLength; _124 = _125, _127++)
            {
                uint _137 = uint(_127 + UniformBlock.BodyDataBufferStartIndex);
                _125 = _124;
                float _147;
                for (int _144 = 0; _144 < BodyDataBuffer._m0[_137].BodyPartIndexLength; _144++, _125 = _147)
                {
                    uint _152 = uint(_144 + BodyDataBuffer._m0[_137].BodyPartIndexStart);
                    for (int _162 = 0; _162 < 16; )
                    {
                        _72[_162] = float2(0.0);
                        _162++;
                        continue;
                    }
                    int _247;
                    if (BodyPartDataBuffer._m0[_152].ShapeType == 0)
                    {
                        for (int _232 = 0; _232 < BodyPartDataBuffer._m0[_152].IntegerFields.x; )
                        {
                            float _240 = (6.283185482025146484375 * float(_232)) / float(BodyPartDataBuffer._m0[_152].IntegerFields.x);
                            _72[_232] = BodyPartDataBuffer._m0[_152].Center + (float2(cos(_240), sin(_240)) * BodyPartDataBuffer._m0[_152].DecimalFields.x);
                            _232++;
                            continue;
                        }
                        _247 = BodyPartDataBuffer._m0[_152].IntegerFields.x;
                    }
                    else
                    {
                        int _228;
                        if (BodyPartDataBuffer._m0[_152].ShapeType == 1)
                        {
                            float _190 = sin(BodyPartDataBuffer._m0[_152].DecimalFields.x);
                            float _191 = cos(BodyPartDataBuffer._m0[_152].DecimalFields.x);
                            float _194 = BodyPartDataBuffer._m0[_152].DecimalFields.y * (-0.5);
                            float _195 = BodyPartDataBuffer._m0[_152].DecimalFields.z * (-0.5);
                            _72[0] = float2(_194, _195);
                            float _198 = BodyPartDataBuffer._m0[_152].DecimalFields.y * 0.5;
                            _72[1] = float2(_198, _195);
                            float _201 = BodyPartDataBuffer._m0[_152].DecimalFields.z * 0.5;
                            _72[2] = float2(_198, _201);
                            _72[3] = float2(_194, _201);
                            for (int _207 = 0; _207 < 4; )
                            {
                                float _221 = _72[_207].x;
                                float _223 = _72[_207].y;
                                _72[_207].x = (_72[_207].x * _191) + (_72[_207].y * (-_190));
                                _72[_207].y = (_221 * _190) + (_223 * _191);
                                _72[_207] += BodyPartDataBuffer._m0[_152].Center;
                                _207++;
                                continue;
                            }
                            _228 = 4;
                        }
                        else
                        {
                            bool _176 = BodyPartDataBuffer._m0[_152].ShapeType == 2;
                            if (_176)
                            {
                                _72[0] = BodyPartDataBuffer._m0[_152].Center;
                                _72[1] = float2(BodyPartDataBuffer._m0[_152].DecimalFields.xy);
                                _72[2] = float2(BodyPartDataBuffer._m0[_152].DecimalFields.zw);
                            }
                            _228 = _176 ? 3 : 1;
                        }
                        _247 = _228;
                    }
                    for (int _249 = 0; _249 < 16; )
                    {
                        _72[_249] += BodyDataBuffer._m0[_137].Offset;
                        _249++;
                        continue;
                    }
                    _147 = _125;
                    float _258;
                    for (int _260 = 0; _260 < _247; _147 = _258, _260++)
                    {
                        int _271;
                        if (_260 == (_247 - 1))
                        {
                            _271 = 0;
                        }
                        else
                        {
                            _271 = _260 + 1;
                        }
                        float4 _280 = float4(_72[_260], _72[_271]);
                        float4 _285 = float4(_110, _122);
                        float2 _348;
                        bool _349;
                        do
                        {
                            float2 _289 = _280.xy;
                            float2 _290 = _280.zw - _289;
                            float2 _291 = _285.zw;
                            float2 _292 = _285.xy;
                            float2 _293 = _291 - _292;
                            float2 _294 = _292 - _289;
                            float _295 = _294.x;
                            float _296 = _293.y;
                            float _298 = _294.y;
                            float _299 = _293.x;
                            float _302 = _290.y;
                            float _304 = _290.x;
                            float _306 = (_295 * _302) - (_298 * _304);
                            float _309 = (_304 * _296) - (_302 * _299);
                            bool _311 = abs(_309) < 0.001000000047497451305389404296875;
                            bool _313 = abs(_306) < 0.001000000047497451305389404296875;
                            bool _318;
                            if (_311)
                            {
                                _318 = !_313;
                            }
                            else
                            {
                                _318 = false;
                            }
                            if (_311 ? _313 : false)
                            {
                                _348 = float2(0.0);
                                _349 = false;
                                break;
                            }
                            else
                            {
                                if (_318)
                                {
                                    _348 = float2(0.0);
                                    _349 = false;
                                    break;
                                }
                                else
                                {
                                    if (!_311)
                                    {
                                        float _329 = ((_295 * _296) - (_298 * _299)) / _309;
                                        float _330 = _306 / _309;
                                        bool _335;
                                        if (_329 >= 0.0)
                                        {
                                            _335 = _329 <= 1.0;
                                        }
                                        else
                                        {
                                            _335 = false;
                                        }
                                        bool _343;
                                        if (_335)
                                        {
                                            bool _342;
                                            if (_330 >= 0.0)
                                            {
                                                _342 = _330 <= 1.0;
                                            }
                                            else
                                            {
                                                _342 = false;
                                            }
                                            _343 = _342;
                                        }
                                        else
                                        {
                                            _343 = false;
                                        }
                                        if (_343)
                                        {
                                            _348 = mix(_292, _291, float2(_330));
                                            _349 = true;
                                            break;
                                        }
                                        _348 = float2(0.0);
                                        _349 = false;
                                        break;
                                    }
                                    else
                                    {
                                        _348 = float2(0.0);
                                        _349 = false;
                                        break;
                                    }
                                    break; // unreachable workaround
                                }
                                break; // unreachable workaround
                            }
                            break; // unreachable workaround
                        } while(false);
                        if (_349)
                        {
                            float _353 = length(_348 - _110);
                            _258 = (_353 < _147) ? _353 : _147;
                        }
                        else
                        {
                            _258 = _147;
                        }
                    }
                }
            }
            LineDataBuffer._m0[_99].Length = _124;
        }
        break;
    } while(false);
}

